# Instructions

During your interaction with the user, if you find anything reusable in this project (e.g. version of a library, model name), especially about a fix to a mistake you made or a correction you received, you should take note in the `Lessons` section in the `.cursorrules` file so you will not make the same mistake again. 

You should also use the `.cursorrules` file as a Scratchpad to organize your thoughts. Especially when you receive a new task, you should first review the content of the Scratchpad, clear old different task if necessary, first explain the task, and plan the steps you need to take to complete the task. You can use todo markers to indicate the progress, e.g.
[X] Task 1
[ ] Task 2

Also update the progress of the task in the Scratchpad when you finish a subtask.
Especially when you finished a milestone, it will help to improve your depth of task accomplishment to use the Scratchpad to reflect and plan.
The goal is to help you maintain a big picture as well as the progress of the task. Always refer to the Scratchpad when you plan the next step.

# Tools

Note all the tools are in python3. So in the case you need to do batch processing, you can always consult the python files and write your own script.

[NOTE TO CURSOR: Since no API key is configured, please ignore both the Screenshot Verification and LLM sections below.]
[NOTE TO USER: If you have configured or plan to configure an API key in the future, simply delete these two notice lines to enable these features.]

## Screenshot Verification

The screenshot verification workflow allows you to capture screenshots of web pages and verify their appearance using LLMs. The following tools are available:

1. Screenshot Capture:
```bash
venv/bin/python3 tools/screenshot_utils.py URL [--output OUTPUT] [--width WIDTH] [--height HEIGHT]
```

2. LLM Verification with Images:
```bash
venv/bin/python3 tools/llm_api.py --prompt "Your verification question" --provider {openai|anthropic} --image path/to/screenshot.png
```

Example workflow:
```python
from screenshot_utils import take_screenshot_sync
from llm_api import query_llm

# Take a screenshot

screenshot_path = take_screenshot_sync('https://example.com', 'screenshot.png')

# Verify with LLM

response = query_llm(
    "What is the background color and title of this webpage?",
    provider="openai",  # or "anthropic"
    image_path=screenshot_path
)
print(response)
```

## LLM

You always have an LLM at your side to help you with the task. For simple tasks, you could invoke the LLM by running the following command:
```
venv/bin/python3 ./tools/llm_api.py --prompt "What is the capital of France?" --provider "anthropic"
```

The LLM API supports multiple providers:
- OpenAI (default, model: gpt-4o)
- Azure OpenAI (model: configured via AZURE_OPENAI_MODEL_DEPLOYMENT in .env file, defaults to gpt-4o-ms)
- DeepSeek (model: deepseek-chat)
- Anthropic (model: claude-3-sonnet-20240229)
- Gemini (model: gemini-pro)
- Local LLM (model: Qwen/Qwen2.5-32B-Instruct-AWQ)

But usually it's a better idea to check the content of the file and use the APIs in the `tools/llm_api.py` file to invoke the LLM if needed.

## Web browser

You could use the `tools/web_scraper.py` file to scrape the web.
```bash
venv/bin/python3 ./tools/web_scraper.py --max-concurrent 3 URL1 URL2 URL3
```
This will output the content of the web pages.

## Search engine

You could use the `tools/search_engine.py` file to search the web.
```bash
venv/bin/python3 ./tools/search_engine.py "your search keywords"
```
This will output the search results in the following format:
```
URL: https://example.com
Title: This is the title of the search result
Snippet: This is a snippet of the search result
```
If needed, you can further use the `web_scraper.py` file to scrape the web page content.

# Lessons

## User Specified Lessons

- You have a python venv in ./venv. Always use (activate) it when doing python development. First, to check whether 'uv' is available, use `which uv`. If that's the case, first activate the venv, and then use `uv pip install` to install packages. Otherwise, fall back to `pip`.
- Include info useful for debugging in the program output.
- Read the file before you try to edit it.
- Due to Cursor's limit, when you use `git` and `gh` and need to submit a multiline commit message, first write the message in a file, and then use `git commit -F <filename>` or similar command to commit. And then remove the file. Include "[Cursor] " in the commit message and PR title.

## Cursor learned

- For search results, ensure proper handling of different character encodings (UTF-8) for international queries
- Add debug information to stderr while keeping the main output clean in stdout for better pipeline integration
- When using seaborn styles in matplotlib, use 'seaborn-v0_8' instead of 'seaborn' as the style name due to recent seaborn version changes
- Use 'gpt-4o' as the model name for OpenAI's GPT-4 with vision capabilities
- When searching for recent news, use the current year (2025) instead of previous years, or simply use the "recent" keyword to get the latest information

# DEBUGGING

## COMPREHENSIVE DEBUGGING APPROACH

Add a comprehensive debugging and brainstorming section to cursorrules that incorporates the
following principles while optimizing for Next.js application architecture:

### CORE DEBUGGING PRINCIPLES
1. Analyze the entire codebase for potential error sources and inefficiencies.
2. Explain problems in simple, non-technical terms.
3. Propose multiple solutions, from quick fixes to comprehensive rewrites.
4. Consider potential side effects of each solution.
5. Explore unconventional approaches and angles.
6. Use techniques like the 'rubber duck method' and 'Five Whys' for deeper analysis.
7. Reverse-engineer problems to gain new insights.
8. Draw inspiration from other programming languages, paradigms, and domains.
9. Visualize code as physical systems to identify weak points.
10. Suggest refactoring for improved maintainability.
11. Identify and improve problematic code patterns.
12. Propose relevant tests to catch similar errors early.
13. Summarize and refine the debugging process for future use.
14. Create checklists for common error types.
15. Relate debugging to broader software development principles.

### NEXT.JS SPECIFIC DEBUGGING CONSIDERATIONS
1. **Server-side vs Client-side Execution Context**
   - Debug issues related to code running in different environments
   - Check for proper use of useEffect, useState and other React hooks
   - Verify proper implementation of getServerSideProps, getStaticProps, and getStaticPaths

2. **Routing and Navigation Issues**
   - Debug problems with Next.js file-based routing system
   - Check for proper implementation of dynamic routes
   - Verify navigation state management and history

3. **API Routes Debugging**
   - Test API endpoints independently from the frontend
   - Verify proper error handling and status codes
   - Check for CORS configuration issues

4. **Build and Deployment Issues**
   - Analyze build logs for warnings and errors
   - Debug differences between development and production environments
   - Check for improper environment variable usage

5. **Performance Optimization**
   - Identify unnecessary re-renders using React DevTools
   - Debug image optimization issues using Next.js Image component
   - Verify proper code splitting and dynamic imports

### ASYNC/AWAIT USAGE FOR NEXT.JS
Ensure asynchronous functions are properly declared with `async` keyword and `await` is used for operations that return promises:

1. Functions performing time-consuming operations are declared as `async`
2. `await` is used before calls to asynchronous functions or methods
3. Promises are not accidentally treated as resolved data
4. Callbacks are used appropriately if not using async/await
5. Proper error handling with try/catch blocks around await statements
6. Check for race conditions in data fetching operations
7. Verify proper loading state management during async operations

### DATA FETCHING PATTERNS
1. Verify correct implementation of SWR or React Query for client-side data fetching
2. Check for proper caching strategies
3. Ensure proper error boundaries around data-dependent components
4. Verify fallback UI during loading states

### STATE MANAGEMENT DEBUGGING
1. Check for proper state initialization
2. Verify state updates trigger appropriate re-renders
3. Look for prop drilling issues that could be solved with context
4. Check for unnecessary global state

### NEXT.JS APP ROUTER SPECIFIC DEBUGGING
1. **Server Components vs Client Components**
   - Verify proper use of "use client" directive
   - Check for proper data passing between server and client components
   - Debug hydration errors and mismatches

2. **Data Fetching in App Router**
   - Check for proper implementation of fetch with appropriate caching options
   - Verify proper error handling in async server components
   - Debug parallel data fetching issues

3. **Route Handlers**
   - Test API endpoints with proper HTTP methods
   - Verify CORS configuration and middleware
   - Debug response serialization issues

### NEXT.JS COMMON ERRORS AND FIXES
1. **Hydration Errors**
   - Look for DOM mismatches between server and client rendering
   - Check for components that render differently based on window/document access
   - Verify usage of dynamic imports with proper loading states

2. **Module Not Found Errors**
   - Check import paths and case sensitivity
   - Verify package installations and dependencies
   - Examine tsconfig.json and jsconfig.json path aliases

3. **API Route Issues**
   - Verify proper response formatting and status codes
   - Check for missing CORS headers when needed
   - Debug middleware execution order

4. **Image Optimization Problems**
   - Verify domains whitelist in next.config.js
   - Check for proper image dimensions and optimization settings
   - Debug blur placeholder and loading behavior

5. **CSS Module Conflicts**
   - Look for global CSS leaks
   - Check for naming collisions in class names
   - Verify proper isolation of styled components

### ADVANCED DEBUGGING TECHNIQUES
1. **Structured Logging**
   - Implement consistent log levels (debug, info, warn, error)
   - Add context to logs (request IDs, user info, etc.)
   - Use JSON formatted logs for easier parsing

2. **Instrumentation**
   - Add performance measurements around critical code paths
   - Track component render counts and durations
   - Monitor memory usage patterns

3. **Error Tracking**
   - Implement global error boundaries with fallback UIs
   - Set up proper error reporting to external services
   - Capture and analyze unhandled promise rejections

4. **Remote Debugging**
   - Use source maps properly in production
   - Set up secure inspection endpoints for production diagnostics
   - Implement feature flags for gradual rollouts

5. **Network Analysis**
   - Monitor API call patterns and timing
   - Check for unnecessary or duplicate network requests
   - Verify proper HTTP caching headers

### DEBUGGING TOOLS INTEGRATION
1. Configure and utilize React DevTools for component inspection
2. Set up proper logging with structured formats
3. Implement error boundaries at strategic component levels
4. Create custom hooks for debugging specific patterns
5. Use Chrome DevTools Performance tab for render performance analysis
6. Leverage Next.js Analytics for production performance monitoring

### CODE QUALITY CHECKS
1. Run ESLint with Next.js specific rules
2. Perform accessibility audits using appropriate tools
3. Check for TypeScript errors and proper type definitions
4. Verify CSS module isolation and styling conflicts
5. Use SonarQube or similar tools to identify code smells and vulnerabilities

### TESTING STRATEGY
1. Implement unit tests for utility functions
2. Add integration tests for key user flows
3. Create E2E tests for critical paths
4. Develop visual regression tests for UI components
5. Add snapshot tests for complex component trees

### RELEASE WORKFLOW
1. Use feature branches and pull requests for code reviews
2. Implement pre-commit hooks for linting and formatting
3. Set up continuous integration with automated tests
4. Create staging environments that mirror production
5. Implement canary deployments for critical changes

### DEVELOPMENT PROCESS GUIDELINES
When encountering issues, reference these methods to think creatively, consider multiple
perspectives, and develop robust, adaptable solutions that address both immediate problems
and potential future issues.

### DOCUMENTATION INTEGRATION
I'm using Perplexity - please prompt me to look up docs on Perplexity when you
believe it would help strengthen our process. Please provide a search prompt to give
me clarity to make sure it takes me to the exact page I can find the docs on, and mention the
most important subjects or sections to bring back so you know how to do something. DO NOT
JUMP TO CONCLUSIONS! Quiet the ego, constantly question your assumptions, do not be a yes
person, I can be wrong, and you should assume I don't know what I'm doing. You're the expert.
I'd like to use your reasoning logic often, especially if we keep getting the same types of
errors more than once in a row.

### ERROR PATTERN RECOGNITION
Look for recurring patterns in errors to identify root causes:

1. **Timing-Based Errors**
   - Race conditions in data fetching
   - Event handling sequencing issues
   - Animation and transition timing problems

2. **Environment-Specific Issues**
   - Development vs production differences
   - Browser compatibility problems
   - Mobile vs desktop rendering discrepancies

3. **Data Flow Problems**
   - Prop drilling complexity
   - Context provider misconfigurations
   - Redux/state management side effects

4. **Performance Bottlenecks**
   - Render blocking operations
   - Excessive re-renders
   - Memory leaks from improper cleanup

5. **Edge Cases**
   - Empty state handling
   - Error state recovery
   - Boundary condition failures

### DEBUGGING METHODOLOGY
Follow these steps for systematic debugging:

1. **Reproduce the Issue**
   - Create a minimal reproduction case
   - Document the exact steps to trigger the error
   - Identify environmental factors that influence the bug

2. **Isolate the Problem**
   - Use binary search through the code/components
   - Comment out sections to narrow down the cause
   - Create simplified test cases

3. **Analyze the Root Cause**
   - Examine error logs and stack traces
   - Trace data flow through the application
   - Check for recent changes that might have introduced the issue

4. **Implement a Solution**
   - Start with the simplest possible fix
   - Consider both immediate fixes and long-term improvements
   - Document the reasoning behind the solution

5. **Verify the Fix**
   - Test in multiple environments
   - Check for regressions
   - Add automated tests to prevent recurrence

6. **Document Lessons Learned**
   - Update this debugging guide with new patterns
   - Share knowledge with the team
   - Improve error handling for similar cases

### NEXT.JS SPECIFIC OPTIMIZATIONS
1. **Server-Side Rendering (SSR) Issues**
   - Debug data fetching timing problems
   - Check for proper error handling during SSR
   - Verify proper hydration after initial render

2. **Static Generation Considerations**
   - Validate getStaticProps and getStaticPaths implementations
   - Debug incremental static regeneration (ISR) issues
   - Check for proper fallback behavior

3. **Client-Side Navigation**
   - Verify proper usage of Next.js Link component
   - Debug router events and lifecycle hooks
   - Check for unnecessary page reloads

4. **Component Design**
   - Look for proper component boundaries
   - Check for excessive prop passing
   - Verify proper use of React.memo and useMemo

5. **CSS and Styling Issues**
   - Debug CSS-in-JS performance problems
   - Check for unused styles and CSS bloat
   - Verify proper media query implementations

### THIRD-PARTY INTEGRATION DEBUGGING
1. **Authentication Services**
   - Debug session persistence issues
   - Check for proper token refresh mechanisms
   - Verify secure storage of credentials

2. **Content Management Systems**
   - Debug data fetching from headless CMS
   - Check for proper content model implementation
   - Verify webhook handling for content updates

3. **Payment Processors**
   - Debug checkout flow issues
   - Verify proper handling of payment intents
   - Check for correct error handling during payment processing

4. **Analytics and Tracking**
   - Debug data collection accuracy
   - Verify proper event triggering
   - Check for performance impact of tracking scripts

5. **External APIs**
   - Debug rate limiting and throttling issues
   - Verify proper error handling for API failures
   - Check for API version compatibility

### CUSTOM HOOKS FOR DEBUGGING
1. **useDebugRender**
   - Track component render counts
   - Log prop changes between renders
   - Measure render timing

2. **useNetworkMonitor**
   - Track API call timing and success rates
   - Log request and response details
   - Monitor for network errors

3. **useStateTracker**
   - Log state changes with previous and current values
   - Track which actions triggered state updates
   - Measure time between state updates

4. **useErrorBoundary**
   - Capture and log component errors
   - Provide fallback UI options
   - Report errors to monitoring services

5. **usePerformanceTracker**
   - Measure critical rendering paths
   - Track time to interactive for components
   - Monitor memory usage patterns

# Scratchpad
